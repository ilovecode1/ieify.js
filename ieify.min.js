//IEify.js v1.0.0 (function(){:if(! 0) return;:var e = "abbr,article,aside,audio,bb,canvas,datagrid,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(','),i = e.length;:while(i--) { document.createElement(e[i])})() ;(function(window,document){:var version = '3.7.3-pre';:var options = window.html5 || {}; var supportsUnknownElements; (function(){:try { var a = document.createElement('a');:a.innerHTML = '<xyz></xyz>';://if the hidden property is implemented we can assume,that the browser supports basic HTML5 Styles supportsHtml5Styles =('hidden' in a);:supportsUnknownElements = a.childNodes.length == 1 ||(function() { // assign a false positive if unable to shiv(document.createElement)('a');:var frag = document.createDocumentFragment();:return(typeof frag.cloneNode == 'undefined' || typeof frag.createDocumentFragment == 'undefined' || typeof frag.createElement == 'undefined')}catch(e){:// assign a false positive if detection fails => unable to shiv supportsHtml5Styles = true;:supportsUnknownElements = true}()); function addStyleSheet(ownerDocument,cssText){:var p = ownerDocument.createElement('p'),parent = ownerDocument.getElementsByTagName('head')[0]|| ownerDocument.documentElement;:p.innerHTML = 'x<style>' + cssText + '</style>';:return parent.insertBefore(p.lastChild,parent.firstChild)}function getElements(){:var elements = html5elements;return typeof elements == 'string' ? elements.split(' '):elements}function addElements(newElements,ownerDocument){:var elements = html5elements;:if(typeof elements != 'string'){ elements = elements.join(' ')}if(typeof newElements != 'string'){:newElements = newElements.join(' ')}function getExpandoData(ownerDocument){:var data = expandoData[ownerDocument[expando]];:if(!data) { data = {}function createElement(nodeName,ownerDocument,data){:if(!ownerDocument) { ownerDocument = document}if (!data){:data = getExpandoData(ownerDocument)}var node; if (data.cache[nodeName]){:node = data.cache[nodeName].cloneNode()}else if (saveClones.test(nodeName)){:node =(data.cache[nodeName]= data.createElem(nodeName)).cloneNode()}function createDocumentFragment(ownerDocument,data){:if(!ownerDocument) { ownerDocument = document}if(supportsUnknownElements){:return ownerDocument.createDocumentFragment()}data = data || getExpandoData(ownerDocument); var clone = data.frag.cloneNode(),elems = getElements(),i = 0,l = elems.length; for(;i<l;i++){:clone.createElement(elems[i])}function shivMethods(ownerDocument,data){:if(!data.cache) { data.cache = {}ownerDocument.createElement = function(nodeName){://abort shiv if(!html5shivMethods) { return data.createElem(nodeName)}; ownerDocument.createDocumentFragment = Function('h,f','return function(){'+'var n=f.cloneNode(),c=n.createElement;'+'h.shivMethods&&('+// unroll the `createElement` calls getElements().join().replace(/[\w\-:]+/g,function(nodeName){:data.createElem(nodeName);:data.frag.createElement(nodeName);:return 'c("' + nodeName + '")'}function shivDocument(ownerDocument){:if(!ownerDocument) { ownerDocument = document}var data = getExpandoData(ownerDocument); if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS){:data.hasCSS = !!addStyleSheet(ownerDocument,// corrects block display not defined in IE6/7/8/9 'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' + // adds styling not present in IE6/7/8/9 'mark{background:#FF0;color:#000}' + // hides non-rendered elements 'template{display:none}')}if (!supportsUnknownElements){:shivMethods(ownerDocument,data)}var html5 ={'elements':options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video','version':version,'shivCSS'(options.shivCSS !== false),'supportsUnknownElements':supportsUnknownElements,'shivMethods'(options.shivMethods !== false),'type':'default',// shivs the document according to the specified `html5` object options 'shivDocument':shivDocument,//creates a shived element createElement:createElement,//creates a shived documentFragment createDocumentFragment:createDocumentFragment,//extends list of elements addElements:addElements}; // expose html5 window.html5 = html5; // shiv the document shivDocument(document); if(typeof module == 'object' && module.exports){:module.exports = html5}(typeof window !== "undefined" ? window : this,document)); (function(win){:// If browser isn't IE, then stop execution! This handles the script '// being loaded by non IE browsers because the developer didn't use // conditional comments. if(true) return;:// =========================== Init Objects ============================ var doc = document;:var root = doc.documentElement;:var xhr = getXHRObject();:var ieVersion = /MSIE(\d+)/.exec(navigator.userAgent)[1];:// If were not in standards mode,IE is too old / new or we can't create // an XMLHttpRequest object then we should get out now. if (doc.compatMode != 'CSS1Compat' || ieVersion<6 || ieVersion>8 || !xhr) { return}// ========================= Common Objects ============================ // Compatiable selector engines in order of CSS3 support. Note: '*' is // a placholder for the object key name. (basically,crude compression) var selectorEngines ={"nw":"*.Dom.select", "MooTools" : "$$", "DOMAssistant" : "*.$", "Prototype" : "$$", "YAHOO" : "*.util.Selector.query", "Sizzle" : "*", "jQuery" : "*", "dojo" : "*.query"}@import "s*(?:(?:(?:url\(\s*(['"]?)(.*)\1)\s*\))|(?:(['"])(.*)\3))[^;:]*;:/g;:var RE_ASSET_URL = /\burl\(\s*(["']?)(?!data:)([^"')]+)\1\s*\)" /g;var RE_PSEUDO_STRUCTURAL = /^:(empty|(first|last|only|nth(-last)?)-(child|of-type))$/; var RE_PSEUDO_ELEMENTS = /:(:first-(?:line|letter))/g; var RE_SELECTOR_GROUP = /(^|})\s*([^\{]*?[\[:][^{]+)/g;var re_selector_parse = /([ +~>])|(:[a-z-]+(?:\(.*?\)+)?)|(\[.*?\])/g;var re_library_incompatible_pseudos = /(:not\()?:(hover|enabled|disabled|focus|checked|target|active|visited|first-line|first-letter)\)?/g;var re_patch_class_name_replace = /[^\w-]/g; // html ui element regexp's var re_input_elements = /^(input|select|textarea|button)$/;:var re_input_checkable_types = /^(checkbox|radio)$/;:// broken attribute selector implementations(ie7/8 native[^=""][$=""]and[*=""]) var broken_attr_implementations = ieversion>6 ? /[\$\^*]=(['"])\1/ : null;" // whitespace normalization regexp's var re_tidy_trailing_whitespace = /([(\[+~])\s+/g;:var re_tidy_leading_whitespace = /\s+([)\]+~])/g;:var re_tidy_consecutive_whitespace = /\s+/g;var re_tidy_trim_whitespace = /^\s*((?:[\s\s]*\s)?)\s*$/;:// string constants var empty_string = "";:var space_string = " ";:var placeholder_string = "$1";:// =========================== patching ================================ // --[patchstylesheet()]---------------------------------------------- // scans the passed csstext for selectors that require emulation and // creates one or more patches for each matched selector. function patchstylesheet(csstext) { return csstext.replace(re_pseudo_elements,placeholder_string). replace(re_selector_group,function(m,prefix,selectortext) { var selectorgroups = selectortext.split(",");:for(var c = 0,cs = selectorgroups.length;:c < cs;:c++) { var selector = normalizeselectorwhitespace(selectorgroups[c]) + space_string;:var patches =[];:selectorgroups[c]= selector.replace(re_selector_parse,function(match,combinator,pseudo,attribute,index) { if(combinator) { if(patches.length>0) { applypatches(selector.substring(0,index),patches);:patches =[]}else{var patch =(pseudo) ? patchpseudoclass(pseudo):patchattribute(attribute)}; // --[patchattribute()]----------------------------------------------- // returns a patch for an attribute selector. function patchattribute( attr ){return(!broken_attr_implementations || broken_attr_implementations.test(attr)) ? { classname:createclassname(attr),applyclass:true}; // --[patchpseudoclass()]--------------------------------------------- // returns a patch for a pseudo-class function patchpseudoclass( pseudo ){:var applyclass = true;:var classname = createclassname(pseudo.slice(1));:var isnegated = pseudo.substring(0,5) == ":not(";:var activateeventname;:var deactivateeventname;// if negated,remove:not() if(isnegated) { pseudo = pseudo.slice(5,-1)}// bracket contents are irrelevant - remove them var bracketindex = pseudo.indexof("(") if (bracketindex>-1){:pseudo = pseudo.substring(0,bracketindex)}// check we're still dealing with a pseudo-class if (pseudo.charat(0) == ":") { switch (pseudo.slice(1)) { case "root":applyClass = function(e) { return isNegated ? e != root : e == root}break; case "target": // :target is only supported in IE8 if (ieVersion == 8){applyclass = function(e) { var handler = function() { var hash = location.hash; var hashid = hash.slice(1); return isnegated ? (hash == empty_string || e.id != hashid):(hash != EMPTY_STRING && e.id == hashID)}applyClass = function(e){addevent( e, isnegated ? deactivateeventname:activateEventName, function() { toggleElementClass( e, className, true )}break; } } return{classname:className, applyClass: applyClass}; }; // --[ applyPatches() ]------------------------------------------------- // uses the passed selector text to find DOM nodes and patch them function applyPatches(selectorText,patches){var elms; // although some selector libraries can find:checked :enabled etc. // we need to find all elements that could have that state because // it can be changed by the user. var domSelectorText = selectorText.replace(RE_LIBRARY_INCOMPATIBLE_PSEUDOS, EMPTY_STRING)}; // =========================== Utility ================================= function createClassName( className ){return namespace + "-" + ((ieversion == 6 && patchie6multipleclasses) ? ie6patchid++:className.replace(RE_PATCH_CLASS_NAME_REPLACE, function(a) { return a.charCodeAt(0)}}; // --[ toggleClass() ]-------------------------------------------------- // adds / removes a className from a string of classNames. Used to // manage multiple class changes without forcing a DOM redraw function toggleClass( classList,className,on ){var re = regexp("(^|\\s)" + classname + "(\\s|$)"); var classexists = re.test(classlist); if (on) { return classexists ? classlist:classList + SPACE_STRING + className}else{return classexists ? trim(classlist.replace(re, placeholder_string)):classList}}; // --[ loadStyleSheet() ]----------------------------------------------- function loadStyleSheet( url ){xhr.open("get", url, false); xhr.send(); return (xhr.status==200) ? xhr.responsetext:EMPTY_STRING}; // absolute path if (/^https?:\/\//i.test(url)){return getprotocolandhost(contexturl) == getprotocolandhost(url) ? url:null}} } });  // @w window reference // @f function reference function ContentLoaded(win,fn){var done = false, top = true, init = function(e) { if (e.type == "readystatechange" && doc.readystate != "complete") return; (e.type == "load" ? win:doc).detachEvent("on" + e.type, init, false)}if (top) poll(); } addEvent(doc,"readystatechange",init); addEvent(win,"load",init); } }; })(this);  (function(){var doc = document;var pie = window['pie']; if( !pie ) { pie = window['pie'] = { css_prefix:'-pie-', STYLE_PREFIX: 'Pie', CLASS_PREFIX: 'pie_', tableCellTags: { 'TD': 1, 'TH': 1},childlessElements:{'table':1, 'THEAD':1, 'TBODY':1, 'TFOOT':1, 'TR':1, 'INPUT':1, 'TEXTAREA':1, 'SELECT':1, 'OPTION':1, 'IMG':1, 'HR':1},focusableElements:{'a':1, 'INPUT':1, 'TEXTAREA':1, 'SELECT':1, 'BUTTON':1},inputButtonTypes:{'submit':1, 'button':1, 'reset':1})/i,unitTypes:{'px':Type.LENGTH, 'em': Type.LENGTH, 'ex': Type.LENGTH, 'mm': Type.LENGTH, 'cm': Type.LENGTH, 'in': Type.LENGTH, 'pt': Type.LENGTH, 'pc': Type.LENGTH, 'deg': Type.ANGLE, 'rad': Type.ANGLE, 'grad': Type.ANGLE},colorFunctions:{'rgb':1, 'rgba': 1, 'hsl': 1, 'hsla': 1}ch = this.ch; css = this.css.substring( this.ch ); firstChar = css.charAt( 0 ); switch( firstChar ){case '#':if( match = css.match( this.hashColor ) ) { this.ch += match[0].length}if( img !== 'none' ){props.bgimages = [ { imgtype:'image', imgUrl: new PIE.Tokenizer( img ).next().tokenValue, imgRepeat: cs[propNames.REPEAT], bgPosition: new PIE.BgPosition( new PIE.Tokenizer( posX + ' '+ posY ).all() )}len = images.length; if( len && images[0] !== 'none' ){repeats = cs[propnames.repeat].split( splitter ); positions = cs[propnames.position].split( splitter ); origins = cs[propnames.origin].split( splitter ); clips = cs[propnames.clip].split( splitter ); sizes = cs[propnames.size].split( splitter ); props.bgimages = []; for( i = 0; i < len; i++ ) { image = images[ i ]; if( image && image !== 'none' ) { sizeparts = sizes[i].split( ' '); props.bgimages.push( { origstring:image + ' '+ repeats[ i ] + ' '+ positions[ i ] + ' / '+ sizes[ i ] + ' '+ origins[ i ] + ' '+ clips[ i ], imgType: 'image', imgUrl: new PIE.Tokenizer( image ).next().tokenValue, imgRepeat: repeats[ i ], bgPosition: new PIE.BgPosition( new PIE.Tokenizer( positions[ i ] ).all() ), bgOrigin: origins[ i ], bgClip: clips[ i ], bgSize: new PIE.BgSize( sizeParts[ 0 ], sizeParts[ 1 ] )}) } ); PIE.BorderStyleInfo = PIE.StyleInfoBase.newStyleInfo({sides:[ 'Top', 'Right', 'Bottom', 'Left' ], namedWidths: { 'thin': '1px', 'medium': '3px', 'thick': '5px'}} } ); return active ?{widths:w, styles: s, colors: c, widthsSame: widthsSame, colorsSame: colorsSame, stylesSame: stylesSame}: null; },getCss: PIE.StyleInfoBase.cacheWhenLocked( function(){var el = this.targetelement, cs = el.currentstyle, css; // don't redraw or hide borders for cells in border-collapse:collapse tables if(!(el.tagname in pie.tablecelltags && el.offsetparent.currentstyle.bordercollapse === 'collapse')) { this.withactualborder(function() { css = cs.borderwidth + '|' + cs.borderstyle + '|' + cs.bordercolor}),withactualborder: function( fn ){:var rs = this.targetelement.runtimestyle,rswidth = rs.borderwidth,rscolor = rs.bordercolor,ret;:if(rswidth) rs.borderwidth = '';:if(rscolor) rs.bordercolor = '';:ret = fn.call(this);:if(rswidth) rs.borderwidth = rswidth;:if(rscolor) rs.bordercolor = rscolor;:return ret}); (function(){pie.borderradiusstyleinfo = pie.styleinfobase.newstyleinfo({ cssproperty:'border-radius',styleproperty:'borderradius',parsecss:function(css) { var p = null,x,y,tokenizer,token,length,hasnonzero = false;:if(css) { tokenizer = new pie.tokenizer(css);:function collectlengths() { var arr =[],num;:while((token = tokenizer.next()) && token.islengthorpercent()) { length = pie.getlength(token.tokenvalue);:num = length.getnumber();:if(num < 0) { return null}if( num>0 ){:hasnonzero = true}return arr.length>0 && arr.length < 5 ?{'tl':arr[0],'tr':arr[1]|| arr[0],'br':arr[2]|| arr[0],'bl':arr[3]|| arr[1]|| arr[0]}// grab the initial sequence of lengths if( x = collectlengths() ){:// see if there is a slash followed by more lengths,for the y-axis radii if(token) { if(token.tokentype & pie.tokenizer.type.operator && token.tokenvalue === '/') { y = collectlengths()}// treat all-zero values the same as no value if( hasnonzero && x && y ){p = { x:x,y:y}); var zero = pie.getlength( '0' ),zeros ={'tl':zero,'tr':zero,'br':zero,'bl':zero}; pie.borderradiusstyleinfo.all_zero ={x:zeros,y:zeros})(); pie.borderimagestyleinfo = pie.styleinfobase.newstyleinfo({cssproperty:'border-image',styleproperty:'borderimage',repeatidents:{ 'stretch':1,'round':1,'repeat':1,'space':1},parsecss: function( css ){:var p = null,tokenizer,token,type,value,slices,widths,outsets,slashcount = 0,type = pie.tokenizer.type,ident = type.ident,number = type.number,percent = type.percent;:if(css) { tokenizer = new pie.tokenizer(css);:p = {}; function isslash( token ){:return token &&(token.tokentype & type.operator) &&(token.tokenvalue === '/')}function isfillident( token ){:return token &&(token.tokentype & ident) &&(token.tokenvalue === 'fill')}function collectslicesetc(){:slices = tokenizer.until(function(tok) { return !(tok.tokentype &(number | percent))}); if( isfillident( tokenizer.next() ) && !p.fill ){:p.fill = true}if( isslash( tokenizer.next() ) ){:slashcount++;:widths = tokenizer.until(function(token) { return !token.islengthorpercent() && !((token.tokentype & ident) && token.tokenvalue === 'auto')}); if( isslash( tokenizer.next() ) ){:slashcount++;:outsets = tokenizer.until(function(token) { return !token.islength()}while( token = tokenizer.next() ){:type = token.tokentype;:value = token.tokenvalue;// numbers and/or 'fill' keyword:slice values. may be followed optionally by width values,followed optionally by outset values if(type &(number | percent) && !slices) { tokenizer.prev();:collectslicesetc()}else if( isfillident( token ) && !p.fill ){:p.fill = true;:collectslicesetc()}// idents: one or values for 'repeat' else if( ( type & ident ) && this.repeatidents[value] && !p.repeat ){p.repeat = { h:value}; if( token = tokenizer.next() ){:if((token.tokentype & ident) && this.repeatidents[token.tokenvalue) { p.repeat.v = token.tokenvalue}// url of the image else if( ( type & type.url ) && !p.src ){:p.src = value}// found something unrecognized; exit. else,// validate what we collected if( !p.src || !slices || slices.length < 1 || slices.length>4 || ( widths && widths.length>4 ) || ( slashcount === 1 && widths.length < 1 ) || ( outsets && outsets.length>4 ) || ( slashcount === 2 && outsets.length < 1 ) ){:return null}// fill in missing values if( !p.repeat ){p.repeat = { h:'stretch'}if( !p.repeat.v ){:p.repeat.v = p.repeat.h}function distributesides( tokens,convertfn ){return { 't':convertfn(tokens[0),'r':convertfn(tokens[1]|| tokens[0),'b':convertfn(tokens[2]|| tokens[0),'l':convertfn(tokens[3]|| tokens[1]|| tokens[0)}p.slice = distributesides( slices,function( tok ){return pie.getlength((tok.tokentype & number) ? tok.tokenvalue + 'px':tok.tokenvalue)}); if( widths && widths[0] ){p.widths = distributesides(widths,function(tok) { return tok.islengthorpercent() ? pie.getlength(tok.tokenvalue):tok.tokenvalue}if( outsets && outsets[0] ){p.outset = distributesides(outsets,function(tok) { return tok.islength() ? pie.getlength(tok.tokenvalue):tok.tokenvalue}); pie.boxshadowstyleinfo = pie.styleinfobase.newstyleinfo({cssproperty:'box-shadow',styleproperty:'boxshadow',parsecss:function(css) { var props,getlength = pie.getlength,type = pie.tokenizer.type,tokenizer;:if(css) { tokenizer = new pie.tokenizer(css);:props = { outset[],inset[]}; function parseitem(){:var token,type,value,color,lengths,inset,len;:while(token = tokenizer.next()) { value = token.tokenvalue;:type = token.tokentype;:if(type & type.operator && value === ',') { break}else if( token.islength() && !lengths ){:tokenizer.prev();:lengths = tokenizer.until(function(token) { return !token.islength()}else if( type & type.color && !color ){:color = value}else if( type & type.ident && value === 'inset' && !inset ){:inset = true}len = lengths && lengths.length; if( len>1 && len < 5 ){(inset ? props.inset:props.outset).push({ xoffset:getlength(lengths[0].tokenvalue),yoffset:getlength(lengths[1].tokenvalue),blur:getlength(lengths[2]? lengths[2].tokenvalue:'0'),spread:getlength(lengths[3]? lengths[3].tokenvalue:'0'),color:pie.getcolor(color || 'currentcolor')}); pie.visibilitystyleinfo = pie.styleinfobase.newstyleinfo({getcss:pie.styleinfobase.cachewhenlocked(function() { var cs = this.targetelement.currentstyle;:return cs.visibility + '|' + cs.display}),parsecss: function(){:var el = this.targetelement,rs = el.runtimestyle,cs = el.currentstyle,rsvis = rs.visibility,csvis;:rs.visibility = '';:csvis = cs.visibility;:rs.visibility = rsvis;return { visible:csvis !== 'hidden',displayed:cs.display !== 'none'}); pie.rendererbase ={newrenderer:function(proto) { function renderer(el,boundsinfo,styleinfos,parent) { this.targetelement = el;:this.boundsinfo = boundsinfo;:this.styleinfos = styleinfos;:this.parent = parent},ispositioned: false,needsupdate: function(){:return false},prepareupdate: pie.emptyfn,updateprops: function(){:this.destroy();:if(this.isactive()) { this.draw()},updatesize: function(){:if(this.isactive()) { this.draw()},addlayer: function( index,el ){:this.removelayer(index);:for(var layers = this._layers ||(this._layers =[),i = index + 1,len = layers.length,layer;:i < len;:i++ ) { layer = layers[i];:if(layer) { break},getlayer: function( index ){:var layers = this._layers;:return layers && layers[index]|| null},removelayer: function( index ){:var layer = this.getlayer(index),box = this._box;:if(layer && box) { box.removechild(layer);:this._layers[index]= null},getshape: function( name,subelname,parent,group ){:var shapes = this._shapes ||(this._shapes = {}),s; if( !shape ),shape = shapes[name]{:shape = shapes[name]= pie.util.createvmlelement('shape');:if(subelname) { shape.appendchild(shape[subelname]= pie.util.createvmlelement(subelname))}if( group ){:parent = this.getlayer(group);:if(!parent) { this.addlayer(group,doc.createelement('group' + group));:parent = this.getlayer(group)},deleteshape: function( name ){:var shapes = this._shapes,shape = shapes && shapes[name];:if(shape) { shape.parentnode.removechild(shape);:delete shapes[name]},getradiipixels: function( radii ){:var el = this.targetelement,bounds = this.boundsinfo.getbounds(),w = bounds.w,h = bounds.h,tlx,tly,trx,try,brx,bry,blx,bly,f;:tlx = radii.x['tl'].pixels(el,w);:tly = radii.y['tl'].pixels(el,h);:trx = radii.x['tr'].pixels(el,w);:try = radii.y['tr'].pixels(el,h);:brx = radii.x['br'].pixels(el,w);:bry = radii.y['br'].pixels(el,h);:blx = radii.x['bl'].pixels(el,w);:bly = radii.y['bl'].pixels(el,h);:// if any corner ellipses overlap,reduce them all by the appropriate factor. this formula // is taken straight from the css3 backgrounds and borders spec. f = math.min(w / (tlx + trx),h / (try + bry),w / (blx + brx),h / (tly + bly));:if(f < 1) { tlx *= f;:tly *= f;:trx *= f;:try *= f;:brx *= f;:bry *= f;:blx *= f;:bly *= f}return{x:{ 'tl':tlx,'tr':trx,'br':brx,'bl':blx},y:{'tl':tly,'tr':try,'br':bry,'bl':bly},getboxpath: function( shrink,mult,radii ){:mult = mult || 1;var r,str,bounds = this.boundsinfo.getbounds(),w = bounds.w * mult,h = bounds.h * mult,radinfo = this.styleinfos.borderradiusinfo,floor = math.floor,ceil = math.ceil,shrinkt = shrink ? shrink.t * mult:0,shrinkr = shrink ? shrink.r * mult:0,shrinkb = shrink ? shrink.b * mult:0,shrinkl = shrink ? shrink.l * mult:0,tlx,tly,trx,try,brx,bry,blx,bly;:if(radii || radinfo.isactive()) { r = this.getradiipixels(radii || radinfo.getprops());:tlx = r.x['tl']* mult;:tly = r.y['tl']* mult;:trx = r.x['tr']* mult;:try = r.y['tr']* mult;:brx = r.x['br']* mult;:bry = r.y['br']* mult;:blx = r.x['bl']* mult;:bly = r.y['bl']* mult;:str = 'm' + floor(shrinkl) + ',' + floor(tly) + 'qy' + floor(tlx) + ',' + floor(shrinkt) + 'l' + ceil(w - trx) + ',' + floor(shrinkt) + 'qx' + ceil(w - shrinkr) + ',' + floor(try) + 'l' + ceil(w - shrinkr) + ',' + ceil(h - bry) + 'qy' + ceil(w - brx) + ',' + ceil(h - shrinkb) + 'l' + floor(blx) + ',' + ceil(h - shrinkb) + 'qx' + floor(shrinkl) + ',' + ceil(h - bly) + 'x e'},hideborder: function(){:var el = this.targetelement,cs = el.currentstyle,rs = el.runtimestyle,tag = el.tagname,isie6 = pie.ieversion === 6,sides,side,i;:if((isie6 &&(tag in pie.childlesselements || tag === 'fieldset')) || tag === 'button' ||(tag === 'input' && el.type in pie.inputbuttontypes)) { rs.borderwidth = '';:sides = this.styleinfos.borderinfo.sides;:for(i = sides.length;:i--;:) { side = sides[i];:rs['padding' + side]= '';rs['padding' + side]=(pie.getlength(cs['padding' + side)).pixels(el) + (pie.getlength(cs['border' + side + 'width')).pixels(el) + (pie.ieversion !== 8 && i % 2 ? 1:0);://needs an extra horizontal pixel to counteract the extra "inner border" going away}else if( isie6 ){:// wrap all the element's children in a custom element, set the element to visiblity:hidden, // and set the wrapper element to visiblity:visible. This hides the outer element's decorations // (background and border) but displays all the contents. // TODO find a better way to do this that doesn't mess up the DOM parent-child relationship, // as this can interfere with other author scripts which add/modify/delete children. Also, this // won't work for elements which cannot take children,e.g. input/button/textarea/img/etc. Look into // using a compositor filter or some other filter which masks the border. if(el.childNodes.length !== 1 || el.firstChild.tagName !== 'ie6-mask') { var cont = doc.createElement('ie6-mask'),s = cont.style,child;:s.visibility = 'visible';:s.zoom = 1;:while(child = el.firstChild) { cont.appendChild(child)}; PIE.RootRenderer = PIE.RendererBase.newRenderer({isActive:function() { var children = this.childRenderers;:for(var i in children) { if(children.hasOwnProperty(i) && children[i].isActive()) { return true},needsUpdate: function(){:return this.styleInfos.visibilityInfo.changed()},updatePos: function(){:if(this.isActive()) { var el = this.getPositioningElement(),par = el,docEl,parRect,tgtCS = el.currentStyle,tgtPos = tgtCS.position,boxPos,s = this.getBox().style,cs,x = 0,y = 0,elBounds = this.boundsInfo.getBounds(),logicalZoomRatio = elBounds.logicalZoomRatio;:if(tgtPos === 'fixed' && PIE.ieVersion > 6) { x = elBounds.x * logicalZoomRatio;:y = elBounds.y * logicalZoomRatio;:boxPos = tgtPos}else{// Get the element's offsets from its nearest positioned ancestor. Uses // getBoundingClientRect for accuracy and speed. do { par = par.offsetParent}boxPos = 'absolute'; } s.position = boxPos; s.left = x; s.top = y; s.zIndex = tgtPos === 'static' ? -1 : tgtCS.zIndex; this.isPositioned = true; } },updateSize: PIE.emptyFn,updateVisibility: function(){var vis = this.styleinfos.visibilityinfo.getprops(); this.getbox().style.display = ( vis.visible && vis.displayed ) ? '':'none'}},getPositioningElement: function(){var el = this.targetelement; return el.tagname in pie.tablecelltags ? el.offsetparent:el}delete this._box; delete this._layers; } } );  PIE.BackgroundRenderer = PIE.RendererBase.newRenderer({boxzindex:2, boxName: 'background', needsUpdate: function() { var si = this.styleInfos}} } // Delete any bgImage shapes previously created which weren't used above i = images ? images.length:0},positionBgImage: function( shape,index ){:var me = this;:PIE.Util.withImageSize(shape.fill.src,function(size) { var el = me.targetElement,bounds = me.boundsInfo.getBounds(),elW = bounds.w,elH = bounds.h;:// It's possible that the element dimensions are zero now but weren't when the original // update executed,make sure that's not the case to avoid divide-by-zero error if( elW && elH ){var fill = shape.fill, si = me.styleinfos, border = si.borderinfo.getprops(), bw = border && border.widths, bwt = bw ? bw['t'].pixels( el ):0, bwR = bw ? bw['r'].pixels( el ) : 0, bwB = bw ? bw['b'].pixels( el ) : 0, bwL = bw ? bw['l'].pixels( el ) : 0, bg = si.backgroundInfo.getProps().bgImages[ index ], bgPos = bg.bgPosition ? bg.bgPosition.coords( el, elW - size.w - bwL - bwR, elH - size.h - bwT - bwB ) : { x:0, y:0},repeat = bg.imgRepeat,pxX,pxY,clipT = 0,clipL = 0,clipR = elW + 1,clipB = elH + 1,//make sure the default clip region is not inside the box (by a subpixel) clipAdjust = PIE.ieVersion === 8 ? 0 : 1; //prior to IE8 requires 1 extra pixel in the image clip region // Positioning - find the pixel offset from the top/left and convert to a ratio // The position is shifted by half a pixel,to adjust for the half-pixel coordorigin shift which is // needed to fix antialiasing but makes the bg image fuzzy. pxX = Math.round( bgPos.x ) + bwL + 0.5; pxY = Math.round( bgPos.y ) + bwT + 0.5; fill.position = ( pxX / elW ) + ',' + ( pxY / elH ); // Set the size of the image. We have to actually set it to px values otherwise it will not honor // the user's browser zoom level and always display at its natural screen size. fill['size']['x']= 1;://Can be any value,just has to be set to "prime" it so the next line works. Weird! fill['size']= size.w + 'px,' + size.h + 'px';:// Repeating - clip the image shape if(repeat && repeat !== 'repeat') { if(repeat === 'repeat-x' || repeat === 'no-repeat') { clipT = pxY + 1;:clipB = pxY + size.h + clipAdjust}if( repeat === 'repeat-y' || repeat === 'no-repeat' ){:clipL = pxX + 1;:clipR = pxX + size.w + clipAdjust},addLinearGradient: function( shape,info ){:var el = this.targetElement,bounds = this.boundsInfo.getBounds(),w = bounds.w,h = bounds.h,fill = shape.fill,stops = info.stops,stopCount = stops.length,PI = Math.PI,GradientUtil = PIE.GradientUtil,perpendicularIntersect = GradientUtil.perpendicularIntersect,distance = GradientUtil.distance,metrics = GradientUtil.getGradientMetrics(el,w,h,info),angle = metrics.angle,startX = metrics.startX,startY = metrics.startY,startCornerX = metrics.startCornerX,startCornerY = metrics.startCornerY,endCornerX = metrics.endCornerX,endCornerY = metrics.endCornerY,deltaX = metrics.deltaX,deltaY = metrics.deltaY,lineLength = metrics.lineLength,vmlAngle,vmlGradientLength,vmlColors,stopPx,vmlOffsetPct,p,i,j,before,after;:// In VML land,the angle of the rendered gradient depends on the aspect ratio of the shape's // bounding box; for example specifying a 45 deg angle actually results in a gradient // drawn diagonally from one corner to its opposite corner,which will only appear to the // viewer as 45 degrees if the shape is equilateral. We adjust for this by taking the x/y deltas // between the start and end points,multiply one of them by the shape's aspect ratio,// and get their arctangent,resulting in an appropriate VML angle. If the angle is perfectly // horizontal or vertical then we don't need to do this conversion. vmlAngle = ( angle % 90 ) ? Math.atan2( deltaX * w / h,deltaY ) / PI * 180 : ( angle + 90 ); // VML angles are 180 degrees offset from CSS angles vmlAngle += 180; vmlAngle = vmlAngle % 360; // Add all the stops to the VML 'colors' list,including the first and last stops. // For each,we find its pixel offset along the gradient-line; if the offset of a stop is less // than that of its predecessor we increase it to be equal. We then map that pixel offset to a // percentage along the VML gradient-line,which runs from shape corner to corner. p = perpendicularIntersect( startCornerX,startCornerY,angle,endCornerX,endCornerY ); vmlGradientLength = distance( startCornerX,startCornerY,p[0],p[1] ); vmlColors = []; p = perpendicularIntersect( startX,startY,angle,startCornerX,startCornerY ); vmlOffsetPct = distance( startX,startY,p[0],p[1] ) / vmlGradientLength * 100; // Find the pixel offsets along the CSS3 gradient-line for each stop. stopPx = []; for( i = 0; i < stopCount; i++ ){stoppx.push( stops[i].offset ? stops[i].offset.pixels( el, linelength ):i === 0 ? 0 : i === stopCount - 1 ? lineLength : null )}PIE.RendererBase.destroy.call( this ); } } );  PIE.BoxShadowOutsetRenderer = PIE.RendererBase.newRenderer({boxzindex:1, boxName: 'outset-box-shadow', needsUpdate: function() { var si = this.styleInfos},draw: function(){var me = this, el = this.targetelement, box = this.getbox(), styleinfos = this.styleinfos, shadowinfos = styleinfos.boxshadowinfo.getprops().outset, radii = styleinfos.borderradiusinfo.getprops(), len = shadowinfos.length, i = len, j, bounds = this.boundsinfo.getbounds(), w = bounds.w, h = bounds.h, clipadjust = pie.ieversion === 8 ? 1:0, //workaround for IE8 bug where VML leaks out top/left of clip region by 1px corners = [ 'tl', 'tr', 'br', 'bl' ], corner, shadowInfo, shape, fill, ss, xOff, yOff, spread, blur, shrink, color, alpha, path, totalW, totalH, focusX, focusY, isBottom, isRight;function getshadowshape( index, corner, xoff, yoff, color, blur, path ) { var shape = me.getshape( 'shadow' + index + corner, 'fill', box, len - index ), fill = shape.fill; // position and size shape['coordsize'] = w * 2 + ',' + h * 2; shape['coordorigin'] = '1,1'; // color and opacity shape['stroked'] = false; shape['filled'] = true; fill.color = color.colorvalue( el ); if( blur ) { fill['type'] = 'gradienttitle'; //makes the vml gradient follow the shape's outline - hooray for undocumented features?!?! fill['color2']= fill.color;:fill['opacity']= 0}while( i-- ){:shadowinfo = shadowinfos[i];:xoff = shadowinfo.xoffset.pixels(el);:yoff = shadowinfo.yoffset.pixels(el);:spread = shadowinfo.spread.pixels(el);:blur = shadowinfo.blur.pixels(el);:color = shadowinfo.color;:// shape path shrink = -spread - blur;:if(!radii && blur) { // if blurring,use a non-null border radius info object so that getboxpath will // round the corners of the expanded shadow shape rather than squaring them off. radii = pie.borderradiusstyleinfo.all_zero}path = this.getboxpath({t:shrink,r:shrink,b:shrink,l:shrink},2,radii ); if( blur ){:totalw =(spread + blur) * 2 + w;:totalh =(spread + blur) * 2 + h;focusx = totalw ? blur * 2 / totalw:0;focusy = totalh ? blur * 2 / totalh:0;if(blur - spread > w / 2 || blur - spread > h / 2) { // if the blur is larger than half the element's narrowest dimension, we cannot do // this with a single shape gradient, because its focussize would have to be less than // zero which results in ugly artifacts. instead we create four shapes, each with its // gradient focus past center, and then clip them so each only shows the quadrant // opposite the focus. for( j = 4; j--; ) { corner = corners[j]; isbottom = corner.charat( 0 ) === 'b'; isright = corner.charat( 1 ) === 'r'; shape = getshadowshape( i, corner, xoff, yoff, color, blur, path ); fill = shape.fill; fill['focusposition'] = ( isright ? 1 - focusx:focusX ) + ',' + ( isBottom ? 1 - focusY : focusY );fill['focussize'] = '0,0'; // clip to show only the appropriate quadrant. add 1px to the top/left clip values // in ie8 to prevent a bug where ie8 displays one pixel outside the clip region. shape.style.clip = 'rect(' + ( ( isbottom ? totalh / 2:0 ) + clipAdjust ) + 'px,' + ( isRight ? totalW : totalW / 2 ) + 'px,' + ( isBottom ? totalH : totalH / 2 ) + 'px,' + ( ( isRight ? totalW / 2 : 0 ) + clipAdjust ) + 'px)'}} } } } );  PIE.ImgRenderer = PIE.RendererBase.newRenderer({boxzindex:6, boxName: 'imgEl', needsUpdate: function() { var si = this.styleInfos}return{w:w, h: h}; },getGradientSvg: function( info,bgWidth,bgHeight ){var el = this.targetelement, stopsinfo = info.stops, stopcount = stopsinfo.length, metrics = pie.gradientutil.getgradientmetrics( el, bgwidth, bgheight, info ), startx = metrics.startx, starty = metrics.starty, endx = metrics.endx, endy = metrics.endy, linelength = metrics.linelength, stoppx, i, j, before, after, svg; // find the pixel offsets along the css3 gradient-line for each stop. stoppx = []; for( i = 0; i < stopcount; i++ ) { stoppx.push( stopsinfo[i].offset ? stopsinfo[i].offset.pixels( el, linelength ):i === 0 ? 0 : i === stopCount - 1 ? lineLength : null )}} ); PIE.IE9BorderImageRenderer = PIE.RendererBase.newRenderer({repeat:'repeat', STRETCH: 'stretch', ROUND: 'round', bgLayerZIndex: 0, needsUpdate: function() { return this.styleInfos.borderImageInfo.changed()}// Build the SVG for the border-image rendering. Add each piece as a pattern,which is then stretched // or repeated as the fill of a rect of appropriate size. svg = [ '<svg width="' + elW + '" height="' + elH + '" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' ]; function addImage( x,y,w,h,cropX,cropY,cropW,cropH,tileW,tileH ){patterns.push( '<pattern patternunits="userspaceonuse" id="pattern' + i + '" '+ 'x="' + (repeath === repeat ? x + w / 2 - tilew / 2:x) + '" '+ 'y="' + (repeatV === REPEAT ? y + h / 2 - tileH / 2 : y) + '" '+ 'width="' + tileW + '" height="' + tileH + '">' + '<svg width="' + tileW + '" height="' + tileH + '" viewBox="' + cropX + ' '+ cropY + ' '+ cropW + ' '+ cropH + '" preserveAspectRatio="none">' + '<image xlink:href="' + imgSrc + '" x="0" y="0" width="' + imgW + '" height="' + imgH + '" />' + '</svg>' + '</pattern>' )}addImage( elW - widthR,widthT,widthR,middleH,imgW - sliceR,sliceT,sliceR,imgMiddleH,widthR,tileSizeR ); // middle right addImage( 0,elH - widthB,widthL,widthB,0,imgH - sliceB,sliceL,sliceB,widthL,widthB ); // bottom left addImage( widthL,elH - widthB,centerW,widthB,sliceL,imgH - sliceB,imgCenterW,sliceB,tileSizeB,widthB ); // bottom center addImage( elW - widthR,elH - widthB,widthR,widthB,imgW - sliceR,imgH - sliceB,sliceR,sliceB,widthR,widthB ); // bottom right svg.push( '<defs>' + patterns.join('\n') + '</defs>' + rects.join('\n') + '</svg>' ); me.parent.setBackgroundLayer( me.bgLayerZIndex,'url(data:image/svg+xml,' + escape( svg.join( '') )+') no-repeat border-box border-box' ); // If the border-image's src wasn't immediately available,the SVG for its background layer // will have been created asynchronously after the main element's update has finished; we'll // therefore need to force the root renderer to sync to the final background once finished. if( isAsync ),svg,tileSizeB = repeatH === STRETCH ? centerW : imgCenterW * widthB / sliceB,tileSizeL = repeatV === STRETCH ? middleH : imgMiddleH * widthL / sliceL,tileSizeR = repeatV === STRETCH ? middleH : imgMiddleH * widthR / sliceR,widthB = widths['b'].pixels( el ),widthL = widths['l'].pixels( el ),widthR = widths['r'].pixels( el ),widthT = widths['t'].pixels( el ){:me.parent.finishUpdate()},imageToDataURI: (function(){:var uris = {}; return function( src,width,height ){:var uri = uris[src],image,canvas;:if(!uri) { image = new Image();:canvas = doc.createElement('canvas');:image.src = src;:canvas.width = width;:canvas.height = height;:canvas.getContext('2d').drawImage(image,0,0);:uri = uris[src]= canvas.toDataURL()})(),destroy: function(),prepareUpdate: PIE.BorderImageRenderer.prototype.prepareUpdate{:var me = this,rs = me.targetElement.runtimeStyle;:me.parent.setBackgroundLayer(me.bgLayerZIndex);:rs.borderColor = rs.borderStyle = rs.borderWidth = ''}); PIE.Element = (function(){:var wrappers = {},activeClass = PIE.CLASS_PREFIX+'active',firstChildClass = PIE.CLASS_PREFIX+'first-child',focusClass = PIE.CLASS_PREFIX+'focus',hoverClass = PIE.CLASS_PREFIX+'hover',ignorePropertyNames =,lazyInitCssProp = PIE.CSS_PREFIX+'lazy-init',pollCssProp = PIE.CSS_PREFIX+'poll',trackActiveCssProp = PIE.CSS_PREFIX+'track-active',trackHoverCssProp = PIE.CSS_PREFIX+'track-hover'{'background':1,'bgColor':1,'display':1},dummyArray = []; function addClass( el,className ){:el.className += ' '+ className}function removeClass( el,className ){:var re = classNameRegExes[className]||(classNameRegExes[className]= new RegExp('\\b' + className + '\\b','g'));:el.className = el.className.replace(re,'')}function delayAddClass( el,className ){:var classes = dummyArray.slice.call(arguments,1),i = classes.length;:setTimeout(function() { if(el) { while(i-- ) { addClass(el,classes[i)}function delayRemoveClass( el,className ){:var classes = dummyArray.slice.call(arguments,1),i = classes.length;:setTimeout(function() { if(el) { while(i-- ) { removeClass(el,classes[i)}function Element( el ){:var renderers,rootRenderer,boundsInfo = new PIE.BoundsInfo(el),styleInfos,styleInfosArr,initializing,initialized,eventsAttached,eventListeners =[],delayed,destroyed,poll;:function init() { if(!initialized) { var docEl,bounds,ieDocMode = PIE.ieDocMode,cs = el.currentStyle,lazy = cs.getAttribute(lazyInitCssProp) === 'true',trackActive = cs.getAttribute(trackActiveCssProp) !== 'false',trackHover = cs.getAttribute(trackHoverCssProp) !== 'false',childRenderers;// polling for size/position changes:default to on in IE8,off otherwise,overridable by -pie-poll poll = cs.getAttribute(pollCssProp);poll = iedocmode > 7 ? poll !== 'false':poll === 'true';:// Force layout so move/resize events will fire. Set this as soon as possible to avoid layout changes // after load,but make sure it only gets called the first time through to avoid recursive calls to init(). if(!initializing) { initializing = 1;:el.runtimeStyle.zoom = 1;:initFirstChildPseudoClass()}boundsInfo.lock(); // If the -pie-lazy-init:true flag is set,check if the element is outside the viewport and if so,delay initialization if( lazy && ( bounds = boundsInfo.getBounds() ) && ( docEl = doc.documentElement || doc.body ) && ( bounds.y>docEl.clientHeight || bounds.x>docEl.clientWidth || bounds.y+bounds.h < 0 || bounds.x+bounds.w < 0 ) ){:if(!delayed) { delayed = 1;:PIE.OnScroll.observe(init)}else{:initialized = 1;:delayed = initializing = 0;:PIE.OnScroll.unobserve(init);// create the style infos and renderers if(iedocmode === 9) { styleinfos = { backgroundinfo:new PIE.BackgroundStyleInfo(el),borderImageInfo:new PIE.BorderImageStyleInfo(el),borderInfo:new PIE.BorderStyleInfo(el);styleinfos = { backgroundinfo:new PIE.BackgroundStyleInfo(el),borderInfo:new PIE.BorderStyleInfo(el),borderImageInfo:new PIE.BorderImageStyleInfo(el),borderRadiusInfo:new PIE.BorderRadiusStyleInfo(el),boxShadowInfo:new PIE.BoxShadowStyleInfo(el),visibilityInfo:new PIE.VisibilityStyleInfo(el)}//new PIE.BoxShadowInsetRenderer( el,boundsInfo,styleInfos,rootRenderer ),; styleInfosArr = [ styleInfos.backgroundInfo,new PIE.BackgroundRenderer( el,boundsInfo,styleInfos,rootRenderer ),new PIE.BorderImageRenderer( el,boundsInfo,styleInfos,rootRenderer ) ]; if( el.tagName === 'IMG' ),new PIE.BorderRenderer( el,boundsInfo,styleInfos,rootRenderer ),styleInfos.borderImageInfo,styleInfos.borderInfo,styleInfos.borderRadiusInfo,styleInfos.boxShadowInfo,styleInfos.visibilityInfo ]; rootRenderer = new PIE.RootRenderer( el,boundsInfo,styleInfos ); childRenderers = [ new PIE.BoxShadowOutsetRenderer( el,boundsInfo,styleInfos,rootRenderer ){:childRenderers.push(new PIE.ImgRenderer(el,boundsInfo,styleInfos,rootRenderer))}PIE.OnResize.observe( handleMoveOrResize ); PIE.OnUnload.observe( removeEventListeners ); } boundsInfo.unlock(); } }  function handleMoveOrResize(){:if(boundsInfo && boundsInfo.hasBeenQueried()) { update()}function update( force ){:if(!destroyed) { if(initialized) { var i,len = renderers.length;:lockAll();:for(i = 0;:i < len;:i++ ) { renderers[i].prepareUpdate()}if( force || boundsInfo.positionChanged() ){:for(i = 0;:i < len;:i++ ) { renderers[i].updatePos()}if( force || boundsInfo.sizeChanged() ){:for(i = 0;:i < len;:i++ ) { renderers[i].updateSize()}function propChanged(){:var i,len = renderers.length,renderer,e = event;:// Some elements like <table> fire onpropertychange events for old-school background properties // ('background','bgColor') when runtimeStyle background properties are changed,which // results in an infinite loop;:therefore we filter out those property names. Also,'display' // is ignored because size calculations don't work correctly immediately when its onpropertychange' // event fires, and because it will trigger an onresize event anyway. if( !destroyed && !( e && e.propertyName in ignorePropertyNames ) ) { if( initialized ) { lockAll()}function mouseReleased(){//must delay this because the mouseup event fires before the:active styles are removed. delayRemoveClass( el, activeClass )}function focused(){//must delay this because the focus event fires before the:focus styles are added. delayAddClass( el, focusClass )}function blurred(){//must delay this because the blur event fires before the:focus styles are removed. delayRemoveClass( el, focusClass )}a = a.parentNode; } } }  function initFirstChildPseudoClass(){var tmpel = el,isfirst = 1:while(tmpEl = tmpEl.previousSibling) { if(tmpEl.nodeType === 1) { isFirst = 0;:break}if( isFirst ){:addClass(el,firstChildClass)}
